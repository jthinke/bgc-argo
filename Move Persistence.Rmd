---
title: "Move persistence"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```
```{r install libraries}
# Function to check if pkgs are installed, and install any missing pkgs

pkgTest <- function(x)
{
  if (!require(x,character.only = TRUE))
  {
    install.packages(x,dep=TRUE,repos='http://cran.us.r-project.org')
    if(!require(x,character.only = TRUE)) stop(x, " :Package not found")
  }
}

# create list of required packages
list.of.packages <- c("sf", "dplyr", "ggplot2", "lubridate","orsifronts",
                      "viridis","ncdf4","raster", "fields","gridExtra",
                      "MASS", "adehabitatLT", "aniMotum") 

# create list of installed packages
pkges = installed.packages()[,"Package"]

# Install and load all required pkgs
for (pk in list.of.packages) {
  pkgTest(pk)
}
```

```{r define functions}

summarize_by_day<-function(x){
  x$day<-lubridate::yday(x$date)
  mlon<-tapply(x$lon360, x$day, mean)
  mlat<-tapply(x$lat, x$day, mean)
  mdate<-tapply(x$date, x$day, mean.Date)
  mdate<-as.POSIXct(as.Date(mdate/(60*60*24), origin="1970-1-1"))
  nx<-length(mdate)
  out<-data.frame(lon=mlon, lat=mlat, lc=rep(1,nx), 
                  date=mdate, spp=rep(x$spp[1], nx), site=rep(x$site[1],nx))
  out$date<-as.character(out$date)
  out$day<-lubridate::yday(out$date)
  out
}

# auxiliary function to bin data by longitude

bin_func<-function(data,  bin_size){
  # bin a vector
  dat<-data.frame(data=data)
  dat.r<-range(pretty(range(dat$data), n=10))
  bins<-seq(from=dat.r[1], by=bin_size, to=dat.r[2])
  n.bins<-length(bins)-1
  dat$index<-1:length(dat$data)
  out<-list()
  for(i in 1:n.bins){
    #print(i)
    dat.b<-dat[dat$data<bins[i+1] & dat$data>bins[i],]
    #print(dim(dat.b))
    # if not data exist in given bin, return 0
    if(dim(dat.b)[1]==0){
      dat.b<-data.frame(data=NA, index=NA, bin=bins[i+1])
      out[[i]]<-dat.b
    } else {
      dat.b$bin<-rep(bins[i+1], dim(dat.b)[1])
      out[[i]]<-dat.b
    }
  }
  out<-do.call("rbind", out)
  out<-out[order(out$index),]
  out<-dplyr::select(out, data, bin)
  out<-na.omit(out)
  out
}

# auxiliary function to calculate mean speeds based on daily mean positions and times

speed_func<-function(dat, vmax=2.778){
  # calculate speed between known geographic coordinates and times
  dat<-na.omit(dat) # exclude data for which position or time is not known
  xy<-dplyr::select(dat, lon, lat)
  tdat<-dplyr::select(dat, date)
  nx<-length(tdat$date)
  dist<-na.omit(geosphere::distGeo(xy))
  bear<-na.omit(geosphere::bearing(xy))
  tdiff<-as.numeric(difftime(tdat$date[-1], tdat$date[-nx], units="secs"))
  spd<-as.numeric(na.omit(dist)/tdiff)
  out<-data.frame(date=dat$date[-nx], spp=dat$spp[-nx], lon=xy$lon[-nx], lat=xy$lat[-nx], dist=dist, time=tdiff, bear=bear, speed=spd)
  out<-out[out$speed<=vmax,]
  out
}
```


# main plot function that runs above auxiliary functions

```{r define main analysis function}

plot_figure_4<-function(){
  # to ensure st_crop function works as intended, implement the line below for now (github.com advice 10/3/2022)
  sf_use_s2(FALSE)
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Import and housekeeping
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  # set data directories for tracks and environmental layers for final plot
  my_wd<-getwd()
  tracks<-paste(my_wd, "/data/tracks/tracks3.csv", sep="")
  track_sum<-paste(my_wd, "/data/tracks/tagstats3.csv", sep="")
  
  # read in the data, created and exported from the compile_data script
  
  dat <- read.csv(tracks)
  dat<-dat[,-1] #exclude first column
  
  #print(length(unique(dat$id)))
  tt_sum<-read.csv(track_sum)
  tt_sum<-tt_sum[,-1] # exclude first column
  
  bloom_deps<-tt_sum$id[tt_sum$RB2==1]
  dat<-dat[dat$id%in%bloom_deps,]
  
  # subset for months April and beyond
  dat<-dat[dat$month>3,]
  
  dat$date<-as.POSIXct(strptime(dat$date, format="%Y-%m-%d %H:%M:%S", tz="GMT"))
  names(dat)[2]<-"lon"
  names(dat)[3]<-"lat"
  names(dat)[4]<-"lc"
  
  
  ##
  #-----------------------------------------------------------------------------------
  # Fit a continuous random walk model for quality control of ARGOS locations
  # Jonsen et al. Movement Ecology (2020) 8:31
  # - This speed filters the data
  # - Change temporally irregular observations into discrete (regular) time-steps
  #--------------------------------------------------------------------------------
  
  # Data must be in a specific order (of columns) and have specific names for foieGras to work
  # rename to df to maintain the original, and select columns needed
  
  df <- dplyr::select(dat, id, date, lc, lon, lat)
  names(df) <- c("id", "date", "lc", "lon", "lat")
  head(df)
  
  #------------------------------------------------------------------
  # Prefilter and fit Random Walk SSM using a 2 hour time step
  # simple 'rw' : crw results in false paths
  # Jonsen also used simple rw for his 2020 SES paper
  #------------------------------------------------------------------
  # vmax also works at 5 (which is too much, but fails at 2.5, 3 and 4 in the fit_mpm step)
  
  fit <- fit_ssm(df,
                 vmax = 5,   # max travel rate (m/s) = 10 km /h
                 min.dt = 60,      # minimum allowable time difference between observations (in minutes)
                 model = "rw", 
                 time.step = 24)   # the regular time interval, in hours to predict to
                 #verbose = 1)     
  
  #saveRDS(fit, "./output/fit_fit_smm_NB.RDS")
  #fit = readRDS("./output/fit_fit_smm_NB.RDS")
  
  fit$ssm[[1]]
  print(fit, n = 1440)
  fg.fitted = grab(fit, what = "fitted", as_sf = F)
  fg.predicted  = grab(fit, what = "predicted", as_sf = F)
  
  FG.dat = fg.predicted
  
  
  # Plot predicted values
  # set a projection 
  prj = " +proj=longlat + ellps = WGS84 + datum=WGS84"  
  
  FG.sf_locs <- sf::st_as_sf(FG.dat, coords = c("lon","lat")) %>% 
    sf::st_set_crs(prj)
  
  # fig.FG.argos = ggplot() + 
  #   # annotation_map_tile(type = esri_ocean,zoomin = 1,progress = "none") +            if downloading# 
  #   #annotation_map_tile(zoom = 1, cachedir = system.file("rosm.cache", package = "ggspatial")) +  # if using downloaded files
  #   geom_sf(FG.sf_locs, aes(size = 0.75, alpha = 0.1)) +  # specified stage as ID above
  #   scale_x_continuous(expand = expand_scale(mult = c(.6, .6))) +
  #   scale_color_brewer(palette = "Dark2") +
  #   theme(legend.position = "none") +
  #   ggtitle("Nonbreeding Adelie penguins from King George Island (2016)", 
  #           subtitle = "All tracks (n = 30)(FoieGras filtered)")
  # 
  # fig.FG.argos
  
  # Save png to disk
  #ggsave("./plots/fig2_foieGras_argos_points.png", width = 5, height = 5, dpi = 400)
  
  #------------------------------------------------------------------
  # plot time-series of the predicted values. 
  #------------------------------------------------------------------
  
  # plot(fit, what = "predicted", type = 1, pages = 0)
  # plot(fit, what = "fitted", type = 2, pages = 0)
  
  # png(filename = "./plots/individuals/ID_timeseries_predicted%03d.png", width = 2000, height = 1300, 
  #      pointsize = 8,  res = 300)
  # plot(fit, what = "predicted", type = 1, pages = 0)
  # dev.off()
  # 
  # png(filename = "./plots/individuals/ID_timeseries_fitted%03d.png", width = 2000, height = 1300, 
  #     pointsize = 8,  res = 300)
  # plot(fit, what = "fitted", type = 2, pages = 0)
  # dev.off()
  
  
  #------------------------------------------------------------------
  # Fit movement persistence model
  #------------------------------------------------------------------
  
  fmp <- fit %>% 
    grab(what = "predicted", as_sf = FALSE) %>%
    dplyr::select(id, date, lon, lat) %>%
    fit_mpm(model = "jmpm", verbose = 1, optim = "nlminb") 
  
  fmp 
  plot(fmp)
  
  
}


```
